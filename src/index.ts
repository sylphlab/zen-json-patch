import { Operation, AddOperation, RemoveOperation, ReplaceOperation } from './types';
import { appendPath } from './path';

/**
 * Compares two JSON-compatible objects and generates an array of JSON Patch operations (RFC 6902).
 *
 * @param obj1 The source object.
 * @param obj2 The target object.
 * @returns An array of JSON Patch operations representing the difference.
 */
export function diff(obj1: any, obj2: any): Operation[] {
  const operations: Operation[] = [];
  // Basic checks
  if (obj1 === obj2) {
    return []; // No operations needed
  }
  if (typeof obj1 !== 'object' || obj1 === null || typeof obj2 !== 'object' || obj2 === null) {
    // If either is not an object, the only possible operation is 'replace' at the root
    return [{ op: 'replace', path: '', value: obj2 }];
  }

  // Start the recursive comparison from the root path ""
  compareValues(obj1, obj2, '', operations);

  return operations;
}

/**
 * Recursively compares two values (potentially nested) and generates patch operations.
 * @param val1 The value from the source object/array.
 * @param val2 The value from the target object/array.
 * @param path The current JSON Pointer path.
 * @param operations The array to accumulate patch operations.
 */
function compareValues(val1: any, val2: any, path: string, operations: Operation[]): void {
  // Strict equality check first
  if (val1 === val2) {
    return;
  }

  // Different types or null -> replace
  if (typeof val1 !== 'object' || val1 === null || typeof val2 !== 'object' || val2 === null || Array.isArray(val1) !== Array.isArray(val2)) {
    operations.push({ op: 'replace', path, value: val2 });
    return; // No further comparison needed after replace
  }

  // Both are arrays -> delegate to array comparison
  if (Array.isArray(val1)) { // We already know val2 is also an array
    // TODO: Implement efficient array comparison
    compareArrays(val1, val2, path, operations); // Defined below
    return;
  }

  // Both are objects -> delegate to object comparison
  // We know they are non-null objects and not arrays
  compareObjects(val1, val2, path, operations); // Defined below
}


/**
 * Compares two objects and generates patch operations.
 * @param obj1 Source object.
 * @param obj2 Target object.
 * @param path Current JSON Pointer path.
 * @param operations Accumulator for operations.
 */
function compareObjects(obj1: { [key: string]: any }, obj2: { [key: string]: any }, path: string, operations: Operation[]): void {
  const keys1 = Object.keys(obj1);
  const keys2 = new Set(Object.keys(obj2)); // Use Set for efficient lookup

  // Check for removed and modified keys
  for (const key of keys1) {
    const currentPath = appendPath(path, key);
    if (!keys2.has(key)) {
      // Key removed
      operations.push({ op: 'remove', path: currentPath });
    } else {
      // Key potentially modified, recurse
      compareValues(obj1[key], obj2[key], currentPath, operations);
      keys2.delete(key); // Remove key from set 2 as it's been handled
    }
  }

  // Check for added keys (remaining keys in keys2)
  for (const key of keys2) {
    const currentPath = appendPath(path, key);
    operations.push({ op: 'add', path: currentPath, value: obj2[key] });
  }
}

/**
 * Compares two arrays and generates patch operations.
 * Placeholder - needs efficient implementation (e.g., LCS).
 * @param arr1 Source array.
 * @param arr2 Target array.
 * @param path Current JSON Pointer path.
 * @param operations Accumulator for operations.
 */
function compareArrays(arr1: any[], arr2: any[], path: string, operations: Operation[]): void {
  // Primitive placeholder: Naive replace if lengths or content differ significantly.
  // This is INEFFICIENT and needs replacement with a proper diff algorithm (LCS/Myers).
  if (arr1.length !== arr2.length || JSON.stringify(arr1) !== JSON.stringify(arr2)) {
    operations.push({ op: 'replace', path, value: arr2 });
    console.warn(`Inefficient array comparison at path: ${path}. Replacing entire array.`); // Keep warn for now
  }
  // Future: Implement LCS or similar algorithm here for add/remove/move operations.
}
// Note: `move` and `copy` operations are optimizations that can be added later
// by detecting sequences of remove/add operations with identical values.
// `test` operations are not typically generated by diffs.
